/**
 * TASK Energy - Callout Management System API
 * COMPLETE CORS-ENABLED VERSION for GitHub Pages
 * Version: 6.1 - Production Ready with Full CORS Support
 */

// CONFIGURATION
const SHEET_ID = '1kS_vO8FfE94LHnv5ftsHqaHLm8Xum0l5W6NvXGlZB1A';
const SHEET_NAME = 'Sheet1';
const DEBUG_MODE = true;

// ============================================
// CORS-ENABLED MAIN ENTRY POINTS
// ============================================

/**
 * Handle GET requests with CORS headers
 */
function doGet(e) {
  try {
    logDebug('=== GET REQUEST RECEIVED WITH CORS ===');
    
    const params = e && e.parameter ? e.parameter : {};
    logDebug('Parameters:', params);
    
    // Test basic sheet access first
    const sheetTest = testBasicSheetAccess();
    if (!sheetTest.success) {
      logDebug('Sheet access failed:', sheetTest.error);
      return createCORSResponse(false, 'Sheet access error: ' + sheetTest.error);
    }
    
    const action = params.action || 'read';
    logDebug('Action requested:', action);
    
    switch (action) {
      case 'read':
        return handleRead(params);
      case 'test':
        return createCORSResponse(true, 'API is working with CORS enabled', { 
          timestamp: new Date().toISOString(),
          sheetDimensions: `${sheetTest.lastRow}x${sheetTest.lastCol}`,
          totalColumns: sheetTest.lastCol,
          corsEnabled: true,
          githubPagesSupported: true,
          apiVersion: '6.1'
        });
      case 'debug':
        return handleDebugInfo();
      case 'headers':
        return getAllHeaders();
      default:
        return createCORSResponse(false, 'Invalid action: ' + action);
    }
    
  } catch (error) {
    logDebug('GET Error caught:', error.toString());
    return createCORSResponse(false, 'GET Error: ' + error.toString());
  }
}

/**
 * Handle POST requests with CORS headers
 */
function doPost(e) {
  try {
    logDebug('=== POST REQUEST RECEIVED WITH CORS ===');
    
    if (!e || !e.postData || !e.postData.contents) {
      return createCORSResponse(false, 'No POST data received');
    }
    
    let requestData;
    try {
      requestData = JSON.parse(e.postData.contents);
      logDebug('Parsed request data:', requestData);
    } catch (parseError) {
      return createCORSResponse(false, 'Invalid JSON: ' + parseError.toString());
    }
    
    const action = requestData.action;
    logDebug('Action requested:', action);
    
    switch (action) {
      case 'create':
        return handleCreate(requestData.callout);
      case 'read':
        return handleRead(requestData.filters || {});
      case 'update':
        return handleUpdate(requestData.calloutId, requestData.updates);
      case 'delete':
        return handleDelete(requestData.calloutId);
      default:
        return createCORSResponse(false, 'Invalid action: ' + action);
    }
    
  } catch (error) {
    logDebug('POST Error caught:', error.toString());
    return createCORSResponse(false, 'POST Error: ' + error.toString());
  }
}

/**
 * Handle OPTIONS requests for CORS preflight
 */
function doOptions(e) {
  logDebug('=== OPTIONS REQUEST (CORS PREFLIGHT) ===');
  return createCORSResponse(true, 'CORS preflight successful', {
    allowedMethods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
    corsEnabled: true
  });
}

// ============================================
// CORS-ENABLED RESPONSE CREATION
// ============================================

/**
 * Create standardized response with comprehensive CORS headers
 */
function createCORSResponse(success, message, data = null) {
  const response = {
    success: success,
    message: message,
    data: data,
    timestamp: new Date().toISOString(),
    cors: 'enabled',
    version: '6.1'
  };
  
  logDebug('Creating CORS response:', { 
    success, 
    message, 
    dataType: data ? typeof data : 'null',
    dataLength: data ? JSON.stringify(data).length : 0 
  });
  
  return ContentService
    .createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, Accept, Origin')
    .setHeader('Access-Control-Max-Age', '86400')
    .setHeader('Access-Control-Allow-Credentials', 'false')
    .setHeader('Vary', 'Origin')
    .setHeader('Cache-Control', 'no-cache, no-store, must-revalidate')
    .setHeader('Pragma', 'no-cache')
    .setHeader('Expires', '0');
}

// ============================================
// SHEET ACCESS WITH ALL COLUMNS
// ============================================

/**
 * Test basic sheet access
 */
function testBasicSheetAccess() {
  try {
    logDebug('Testing sheet access...');
    logDebug('Sheet ID:', SHEET_ID);
    logDebug('Sheet Name:', SHEET_NAME);
    
    const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    if (!spreadsheet) {
      return { success: false, error: 'Cannot open spreadsheet' };
    }
    
    logDebug('Spreadsheet opened successfully');
    logDebug('Spreadsheet name:', spreadsheet.getName());
    
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    if (!sheet) {
      const availableSheets = spreadsheet.getSheets().map(s => s.getName());
      return { 
        success: false, 
        error: `Sheet '${SHEET_NAME}' not found. Available: ${availableSheets.join(', ')}` 
      };
    }
    
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    
    logDebug('Sheet dimensions:', lastRow, 'rows x', lastCol, 'columns');
    
    return { 
      success: true, 
      sheet: sheet, 
      lastRow: lastRow, 
      lastCol: lastCol,
      spreadsheetName: spreadsheet.getName()
    };
    
  } catch (error) {
    logDebug('Sheet access error:', error.toString());
    return { success: false, error: error.toString() };
  }
}

/**
 * Get all headers from the sheet with CORS
 */
function getAllHeaders() {
  try {
    logDebug('=== GETTING ALL HEADERS WITH CORS ===');
    
    const sheet = getSheet();
    const lastCol = sheet.getLastColumn();
    
    logDebug('Reading all', lastCol, 'column headers');
    
    const headerRow = sheet.getRange(1, 1, 1, lastCol).getValues()[0];
    const headers = headerRow.map((h, index) => ({
      index: index + 1,
      name: (h || '').toString().trim(),
      hasValue: h && h.toString().trim() !== ''
    }));
    
    const validHeaders = headers.filter(h => h.hasValue);
    
    logDebug('Total columns:', lastCol);
    logDebug('Headers with values:', validHeaders.length);
    
    return createCORSResponse(true, 'All headers retrieved with CORS support', {
      totalColumns: lastCol,
      validHeaders: validHeaders.length,
      headers: validHeaders,
      allHeaders: headers,
      corsEnabled: true
    });
    
  } catch (error) {
    logDebug('Get headers error:', error.toString());
    return createCORSResponse(false, 'Headers error: ' + error.toString());
  }
}

/**
 * Get sheet with error handling
 */
function getSheet() {
  const result = testBasicSheetAccess();
  if (!result.success) {
    throw new Error(result.error);
  }
  return result.sheet;
}

// ============================================
// CORS-ENABLED READ OPERATION
// ============================================

/**
 * Handle READ operations with CORS support and improved data validation
 */
function handleRead(filters = {}) {
  try {
    logDebug('=== STARTING CORS-ENABLED READ OPERATION (ALL COLUMNS) ===');
    logDebug('Filters:', filters);
    
    const sheet = getSheet();
    const lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    
    logDebug('Sheet info - Rows:', lastRow, 'Columns:', lastCol);
    
    if (lastRow === 0) {
      return createCORSResponse(true, 'Sheet is empty', {
        callouts: [],
        stats: { total: 0, new: 0, approved: 0, pending: 0, urgent: 0 },
        corsEnabled: true
      });
    }
    
    if (lastRow === 1) {
      return createCORSResponse(true, 'Only headers found, no data rows', {
        callouts: [],
        stats: { total: 0, new: 0, approved: 0, pending: 0, urgent: 0 },
        corsEnabled: true
      });
    }
    
    logDebug('Reading ALL', lastCol, 'columns of', lastRow, 'rows');
    
    // Read ALL data from the sheet
    let data;
    try {
      data = sheet.getRange(1, 1, lastRow, lastCol).getValues();
    } catch (rangeError) {
      logDebug('Failed to read all columns, trying batch approach...');
      return handleReadInBatches(sheet, lastRow, lastCol, filters);
    }
    
    logDebug('Data retrieved - Size:', data.length, 'x', data[0].length);
    
    // Process headers - ALL headers
    const headerRow = data[0];
    const allHeaders = headerRow.map(h => (h || '').toString().trim());
    const validHeaders = allHeaders.filter(h => h !== '');
    
    logDebug('Total headers found:', allHeaders.length);
    logDebug('Valid headers found:', validHeaders.length);
    logDebug('First 10 headers:', validHeaders.slice(0, 10));
    logDebug('Last 10 headers:', validHeaders.slice(-10));
    
    // Process data rows with IMPROVED validation
    const dataRows = data.slice(1);
    logDebug('Data rows to process:', dataRows.length);
    
    const callouts = [];
    let processedRows = 0;
    let skippedRows = 0;
    
    dataRows.forEach((row, index) => {
      // IMPROVED: More lenient data validation
      const calloutId = (row[0] || '').toString().trim();
      const customer = (row[8] || '').toString().trim();
      const rigNumber = (row[9] || '').toString().trim();
      
      const hasKeyData = calloutId !== '' || customer !== '' || rigNumber !== '';
      const hasAnyData = row.some(cell => cell && cell.toString().trim() !== '');
      const isValidRow = hasKeyData || hasAnyData;
      
      logDebug(`Row ${index + 2}: CalloutID="${calloutId}", Customer="${customer}", RIG="${rigNumber}", Valid=${isValidRow}`);
      
      if (isValidRow) {
        const callout = {};
        
        // Map ALL row data to headers
        allHeaders.forEach((header, colIndex) => {
          if (header && colIndex < row.length) {
            const value = (row[colIndex] || '').toString().trim();
            callout[header] = value;
          }
        });
        
        // Add metadata
        callout._rowIndex = index + 2;
        callout._totalFields = Object.keys(callout).length;
        callout._hasKeyData = hasKeyData;
        callout._debugInfo = {
          calloutId: calloutId,
          customer: customer,
          rigNumber: rigNumber
        };
        
        callouts.push(callout);
        processedRows++;
        
        logDebug(`✅ Row ${index + 2} ACCEPTED: ID="${calloutId}", Customer="${customer}"`);
      } else {
        skippedRows++;
        logDebug(`❌ Row ${index + 2} SKIPPED: No valid data found`);
      }
    });
    
    logDebug('PROCESSING SUMMARY:');
    logDebug('- Total data rows:', dataRows.length);
    logDebug('- Processed (accepted):', processedRows);
    logDebug('- Skipped (rejected):', skippedRows);
    logDebug('- Final callouts created:', callouts.length);
    
    if (callouts.length > 0) {
      logDebug('Sample callout total fields:', callouts[0]._totalFields);
      logDebug('Sample callout keys (first 15):', Object.keys(callouts[0]).slice(0, 15));
      
      const sampleCallout = callouts[0];
      logDebug('Sample callout key data:');
      logDebug('- Callout ID:', sampleCallout['Callout ID']);
      logDebug('- Customer:', sampleCallout['Customer']);
      logDebug('- Status:', sampleCallout['Status']);
      logDebug('- RIG Number:', sampleCallout['RIG Number']);
      logDebug('- Well Name:', sampleCallout['Well Name']);
    } else {
      logDebug('⚠️ WARNING: No callouts created - all rows were filtered out');
    }
    
    // Apply filters
    let filteredCallouts = callouts;
    if (Object.keys(filters).length > 0) {
      filteredCallouts = callouts.filter(callout => {
        return Object.entries(filters).every(([key, value]) => {
          const calloutValue = (callout[key] || '').toString().toLowerCase();
          const filterValue = value.toString().toLowerCase();
          return calloutValue.includes(filterValue);
        });
      });
      logDebug('After filtering:', filteredCallouts.length, 'callouts');
    }
    
    // Calculate statistics
    const stats = calculateStats(filteredCallouts);
    logDebug('Statistics:', stats);
    
    const result = {
      callouts: filteredCallouts,
      stats: stats,
      debug: {
        totalRows: lastRow,
        totalCols: lastCol,
        totalHeaders: allHeaders.length,
        validHeaders: validHeaders.length,
        dataRowsFound: dataRows.length,
        rowsProcessed: processedRows,
        rowsSkipped: skippedRows,
        finalCallouts: filteredCallouts.length,
        fieldsPerCallout: callouts.length > 0 ? callouts[0]._totalFields : 0,
        timestamp: new Date().toISOString(),
        validationMethod: 'improved_key_field_check',
        corsEnabled: true,
        githubPagesCompatible: true
      }
    };
    
    logDebug('CORS-enabled read operation completed successfully');
    logDebug('Response data size:', JSON.stringify(result).length, 'characters');
    
    return createCORSResponse(true, 'Complete callout data retrieved successfully with CORS', result);
    
  } catch (error) {
    logDebug('CORS-enabled read operation failed:', error.toString());
    return createCORSResponse(false, 'Read failed: ' + error.toString());
  }
}

/**
 * Handle reading in batches if full read fails (with CORS)
 */
function handleReadInBatches(sheet, lastRow, lastCol, filters) {
  try {
    logDebug('=== CORS-ENABLED BATCH READ APPROACH ===');
    
    const batchSize = 50;
    const batches = Math.ceil(lastCol / batchSize);
    
    logDebug('Reading in', batches, 'batches of', batchSize, 'columns each');
    
    // First, get all headers
    const allHeaders = [];
    for (let batch = 0; batch < batches; batch++) {
      const startCol = batch * batchSize + 1;
      const endCol = Math.min((batch + 1) * batchSize, lastCol);
      const headerBatch = sheet.getRange(1, startCol, 1, endCol - startCol + 1).getValues()[0];
      allHeaders.push(...headerBatch);
    }
    
    logDebug('Headers retrieved in batches:', allHeaders.length);
    
    // Then get all data
    const allData = [];
    for (let row = 1; row <= lastRow; row++) {
      const rowData = [];
      for (let batch = 0; batch < batches; batch++) {
        const startCol = batch * batchSize + 1;
        const endCol = Math.min((batch + 1) * batchSize, lastCol);
        const dataBatch = sheet.getRange(row, startCol, 1, endCol - startCol + 1).getValues()[0];
        rowData.push(...dataBatch);
      }
      allData.push(rowData);
    }
    
    logDebug('Data retrieved in batches:', allData.length, 'rows');
    
    // Process the batched data with improved validation
    const validHeaders = allHeaders.map(h => (h || '').toString().trim());
    const dataRows = allData.slice(1);
    
    const callouts = [];
    dataRows.forEach((row, index) => {
      const calloutId = (row[0] || '').toString().trim();
      const customer = (row[8] || '').toString().trim();
      const rigNumber = (row[9] || '').toString().trim();
      
      const hasKeyData = calloutId !== '' || customer !== '' || rigNumber !== '';
      const hasAnyData = row.some(cell => cell && cell.toString().trim() !== '');
      const isValidRow = hasKeyData || hasAnyData;
      
      if (isValidRow) {
        const callout = {};
        validHeaders.forEach((header, colIndex) => {
          if (header && colIndex < row.length) {
            const value = (row[colIndex] || '').toString().trim();
            callout[header] = value;
          }
        });
        callout._rowIndex = index + 2;
        callouts.push(callout);
      }
    });
    
    const stats = calculateStats(callouts);
    
    return createCORSResponse(true, 'Batch read completed successfully with CORS', {
      callouts: callouts,
      stats: stats,
      debug: {
        method: 'batch',
        batches: batches,
        batchSize: batchSize,
        totalHeaders: allHeaders.length,
        totalCallouts: callouts.length,
        corsEnabled: true,
        githubPagesCompatible: true
      }
    });
    
  } catch (batchError) {
    logDebug('CORS-enabled batch read failed:', batchError.toString());
    return createCORSResponse(false, 'Batch read failed: ' + batchError.toString());
  }
}

// ============================================
// CORS-ENABLED CRUD OPERATIONS
// ============================================

/**
 * Handle CREATE operations with CORS
 */
function handleCreate(calloutData) {
  try {
    logDebug('=== STARTING CORS-ENABLED CREATE OPERATION ===');
    
    if (!calloutData) {
      return createCORSResponse(false, 'No callout data provided');
    }
    
    const sheet = getSheet();
    const lastCol = sheet.getLastColumn();
    
    // Get ALL headers
    const headerRow = sheet.getRange(1, 1, 1, lastCol).getValues()[0];
    const headers = headerRow.map(h => (h || '').toString().trim());
    
    logDebug('Using all', headers.length, 'headers for create operation');
    
    // Create row data for ALL columns
    const rowData = headers.map(header => {
      if (header && calloutData[header] !== undefined) {
        return calloutData[header];
      }
      
      // Set default values
      const lowerHeader = header.toLowerCase();
      if (lowerHeader.includes('timestamp') || lowerHeader.includes('created')) {
        return new Date().toISOString();
      }
      if (lowerHeader.includes('status')) {
        return 'New Callout';
      }
      if (lowerHeader.includes('callout') && lowerHeader.includes('id')) {
        return 'CL-' + Date.now();
      }
      
      return '';
    });
    
    sheet.appendRow(rowData);
    const newRowIndex = sheet.getLastRow();
    
    logDebug('Row added at index:', newRowIndex);
    
    return createCORSResponse(true, 'Callout created successfully', {
      rowIndex: newRowIndex,
      calloutId: rowData[0] || 'CL-' + Date.now(),
      totalFieldsSet: rowData.filter(v => v !== '').length,
      corsEnabled: true
    });
    
  } catch (error) {
    logDebug('CORS-enabled create operation failed:', error.toString());
    return createCORSResponse(false, 'Create failed: ' + error.toString());
  }
}

/**
 * Handle UPDATE operations with CORS
 */
function handleUpdate(calloutId, updates) {
  try {
    logDebug('=== STARTING CORS-ENABLED UPDATE OPERATION ===');
    logDebug('Callout ID:', calloutId);
    logDebug('Updates:', updates);
    
    if (!calloutId || !updates) {
      return createCORSResponse(false, 'Missing calloutId or updates');
    }
    
    const sheet = getSheet();
    const lastCol = sheet.getLastColumn();
    
    // Get ALL headers
    const headerRow = sheet.getRange(1, 1, 1, lastCol).getValues()[0];
    const headers = headerRow.map(h => (h || '').toString().trim());
    
    // Assume calloutId is the row number
    const rowIndex = parseInt(calloutId);
    if (isNaN(rowIndex) || rowIndex < 2) {
      return createCORSResponse(false, 'Invalid callout ID format');
    }
    
    let updatedFields = [];
    
    // Update each field in ANY column
    Object.entries(updates).forEach(([field, value]) => {
      const colIndex = headers.indexOf(field);
      if (colIndex >= 0) {
        try {
          sheet.getRange(rowIndex, colIndex + 1).setValue(value);
          logDebug(`Updated ${field} (col ${colIndex + 1}) in row ${rowIndex}`);
          updatedFields.push(field);
        } catch (updateError) {
          logDebug(`Failed to update ${field}:`, updateError.toString());
        }
      } else {
        logDebug(`Header not found for field: ${field}`);
      }
    });
    
    // Update timestamp
    const timestampCol = headers.findIndex(h => {
      const lowerH = h.toLowerCase();
      return lowerH.includes('updated') || lowerH.includes('modified') || lowerH.includes('timestamp');
    });
    
    if (timestampCol >= 0) {
      try {
        sheet.getRange(rowIndex, timestampCol + 1).setValue(new Date().toISOString());
        updatedFields.push('timestamp');
      } catch (timestampError) {
        logDebug('Failed to update timestamp:', timestampError.toString());
      }
    }
    
    return createCORSResponse(true, 'Callout updated successfully', {
      rowIndex: rowIndex,
      updatedFields: updatedFields,
      totalHeadersAvailable: headers.length,
      corsEnabled: true
    });
    
  } catch (error) {
    logDebug('CORS-enabled update operation failed:', error.toString());
    return createCORSResponse(false, 'Update failed: ' + error.toString());
  }
}

/**
 * Handle DELETE operations with CORS
 */
function handleDelete(calloutId) {
  try {
    logDebug('=== STARTING CORS-ENABLED DELETE OPERATION ===');
    
    if (!calloutId) {
      return createCORSResponse(false, 'No callout ID provided');
    }
    
    const updates = { 
      Status: 'Deleted',
      Timestamp: new Date().toISOString()
    };
    
    return handleUpdate(calloutId, updates);
    
  } catch (error) {
    logDebug('CORS-enabled delete operation failed:', error.toString());
    return createCORSResponse(false, 'Delete failed: ' + error.toString());
  }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Calculate statistics from callouts
 */
function calculateStats(callouts) {
  const stats = {
    total: callouts.length,
    new: 0,
    approved: 0,
    pending: 0,
    urgent: 0
  };
  
  callouts.forEach(callout => {
    // Try multiple possible status column names
    const status = (
      callout.Status || 
      callout.status || 
      callout.State || 
      callout.state || 
      callout['Callout Status'] ||
      ''
    ).toLowerCase();
    
    // Try multiple possible priority column names
    const priority = (
      callout.Priority || 
      callout.priority || 
      callout.Urgency || 
      callout.urgency || 
      callout['Priority Level'] ||
      ''
    ).toLowerCase();
    
    // Count based on status
    if (status.includes('new')) stats.new++;
    if (status.includes('approved') || status.includes('complete')) stats.approved++;
    if (status.includes('pending') || status.includes('waiting')) stats.pending++;
    
    // Count urgent items
    if (priority.includes('urgent') || priority.includes('high')) stats.urgent++;
  });
  
  return stats;
}

/**
 * Debug logging
 */
function logDebug(message, ...args) {
  if (DEBUG_MODE) {
    console.log('[DEBUG]', new Date().toISOString(), message, ...args);
  }
}

/**
 * Handle debug info request with CORS
 */
function handleDebugInfo() {
  try {
    const sheetTest = testBasicSheetAccess();
    
    const debugInfo = {
      sheetAccess: sheetTest.success,
      sheetError: sheetTest.error || null,
      sheetDimensions: sheetTest.success ? `${sheetTest.lastRow}x${sheetTest.lastCol}` : null,
      spreadsheetName: sheetTest.spreadsheetName || null,
      timestamp: new Date().toISOString(),
      user: Session.getActiveUser().getEmail(),
      corsEnabled: true,
      githubPagesSupported: true,
      apiVersion: '6.1',
      config: {
        SHEET_ID: SHEET_ID,
        SHEET_NAME: SHEET_NAME,
        DEBUG_MODE: DEBUG_MODE
      }
    };
    
    if (sheetTest.success) {
      try {
        const sheet = sheetTest.sheet;
        const maxCols = Math.min(sheetTest.lastCol, 10);
        const maxRows = Math.min(sheetTest.lastRow, 5);
        const sampleData = sheet.getRange(1, 1, maxRows, maxCols).getValues();
        debugInfo.sampleData = sampleData;
        debugInfo.sampleDataSize = `${maxRows}x${maxCols}`;
      } catch (e) {
        debugInfo.sampleDataError = e.toString();
      }
    }
    
    return createCORSResponse(true, 'Debug info retrieved with CORS support', debugInfo);
    
  } catch (error) {
    return createCORSResponse(false, 'Debug failed: ' + error.toString());
  }
}

// ============================================
// COMPREHENSIVE TEST FUNCTIONS WITH CORS
// ============================================

/**
 * Test to check for specific important callout fields (with CORS)
 */
function testSpecificFields() {
  logDebug('=== TESTING SPECIFIC CALLOUT FIELDS WITH CORS ===');
  
  try {
    const result = handleRead({});
    const content = JSON.parse(result.getBlob().getDataAsString());
    
    if (!content.success || content.data.callouts.length === 0) {
      return 'FAILED: No callouts found for field testing';
    }
    
    const sampleCallout = content.data.callouts[0];
    const allFields = Object.keys(sampleCallout);
    
    logDebug('Total fields in callout:', allFields.length);
    
    const criticalFields = [
      'Contact Person', 'Callout Completed By', 'Contact Number', 'Designation',
      'Equipment Required Date', 'Equipment Required Time', 'Crew Required Date', 'Crew Required Time',
      'Latitude', 'Longitude', 'Survey Start Depth', 'Survey End Depth', 'Survey Interval',
      'Authorization', 'Comments', 'Priority', 'Urgency',
      'Max Down Hole Temp', 'H2S Level', 'Well Profile'
    ];
    
    const foundFields = [];
    const missingFields = [];
    
    criticalFields.forEach(field => {
      if (allFields.includes(field)) {
        const value = sampleCallout[field];
        foundFields.push({
          field: field,
          hasValue: value && value.toString().trim() !== '',
          value: value ? value.toString().substring(0, 50) : 'EMPTY'
        });
      } else {
        missingFields.push(field);
      }
    });
    
    const summary = `
CORS-ENABLED FIELD TEST SUMMARY:
- Total fields: ${allFields.length}
- Critical fields found: ${foundFields.length}/${criticalFields.length}
- Fields with data: ${foundFields.filter(f => f.hasValue).length}
- Missing fields: ${missingFields.length}
- CORS: Enabled
    `;
    
    logDebug(summary);
    return summary;
    
  } catch (error) {
    logDebug('❌ CORS field test error:', error.toString());
    return 'ERROR: ' + error.toString();
  }
}

/**
 * Quick test with full data and CORS
 */
function quickTestFull() {
  logDebug('=== QUICK TEST WITH FULL DATA AND CORS ===');
  
  try {
    const sheetTest = testBasicSheetAccess();
    logDebug('Sheet access:', sheetTest.success ? '✅' : '❌');
    
    if (!sheetTest.success) {
      return 'FAILED: ' + sheetTest.error;
    }
    
    logDebug('Sheet dimensions:', sheetTest.lastRow, 'x', sheetTest.lastCol);
    
    const readResult = handleRead({});
    const readBlob = readResult.getBlob().getDataAsString();
    const readContent = JSON.parse(readBlob);
    
    if (readContent.success) {
      logDebug('✅ CORS-enabled full read successful');
      logDebug('Total callouts:', readContent.data.callouts.length);
      logDebug('CORS enabled:', readContent.data.debug.corsEnabled);
      logDebug('GitHub Pages compatible:', readContent.data.debug.githubPagesCompatible);
      
      return `SUCCESS: Found ${readContent.data.callouts.length} callouts with CORS enabled`;
    } else {
      logDebug('❌ CORS-enabled full read failed:', readContent.message);
      return 'FAILED: ' + readContent.message;
    }
    
  } catch (error) {
    logDebug('❌ CORS quick test error:', error.toString());
    return 'ERROR: ' + error.toString();
  }
}

/**
 * Quick test function - can be run manually (with CORS)
 */
function quickTest() {
  logDebug('=== CORS-ENABLED QUICK TEST START ===');
  
  try {
    // Test 1: Sheet access
    logDebug('Test 1: Sheet access');
    const sheetTest = testBasicSheetAccess();
    logDebug('Sheet access result:', sheetTest.success);
    
    if (!sheetTest.success) {
      logDebug('Sheet access failed:', sheetTest.error);
      return 'FAILED: Sheet access error - ' + sheetTest.error;
    }
    
    logDebug('✅ Sheet access successful');
    logDebug('Sheet name:', sheetTest.spreadsheetName);
    logDebug('Dimensions:', sheetTest.lastRow, 'x', sheetTest.lastCol);
    
    // Test 2: CORS-enabled read operation
    logDebug('Test 2: CORS-enabled read operation');
    const readResult = handleRead({});
    const readBlob = readResult.getBlob().getDataAsString();
    const readData = JSON.parse(readBlob);
    logDebug('Read result:', readData.success);
    
    if (readData.success) {
      logDebug('✅ CORS-enabled read operation successful');
      logDebug('Callouts found:', readData.data.callouts.length);
      logDebug('Stats:', readData.data.stats);
      logDebug('CORS enabled:', readData.data.debug.corsEnabled);
      logDebug('GitHub Pages compatible:', readData.data.debug.githubPagesCompatible);
      
      if (readData.data.callouts.length > 0) {
        logDebug('Sample callout keys:', Object.keys(readData.data.callouts[0]).slice(0, 5));
      }
    } else {
      logDebug('❌ CORS-enabled read operation failed:', readData.message);
    }
    
    logDebug('=== CORS-ENABLED QUICK TEST COMPLETE ===');
    return readData.success ? 
      `SUCCESS: Found ${readData.data.callouts.length} callouts with CORS enabled and GitHub Pages support` : 
      'FAILED: ' + readData.message;
    
  } catch (error) {
    logDebug('❌ CORS test error:', error.toString());
    return 'FAILED: ' + error.toString();
  }
}

/**
 * Simple sheet info function with CORS
 */
function getSheetInfo() {
  try {
    const sheetTest = testBasicSheetAccess();
    
    if (sheetTest.success) {
      console.log('✅ SUCCESS WITH CORS');
      console.log('Spreadsheet:', sheetTest.spreadsheetName);
      console.log('Sheet:', SHEET_NAME);
      console.log('Dimensions:', sheetTest.lastRow, 'rows x', sheetTest.lastCol, 'columns');
      console.log('CORS: Enabled');
      console.log('GitHub Pages: Supported');
      
      if (sheetTest.lastRow > 0) {
        const headers = sheetTest.sheet.getRange(1, 1, 1, Math.min(sheetTest.lastCol, 10)).getValues()[0];
        console.log('Sample headers:', headers.filter(h => h).slice(0, 5));
      }
      
      return 'Sheet info logged to console with CORS support';
    } else {
      console.log('❌ FAILED:', sheetTest.error);
      return sheetTest.error;
    }
    
  } catch (error) {
    console.log('❌ ERROR:', error.toString());
    return error.toString();
  }
}
